### `A. Entangled Coins`

- 给定一堆$01$硬币，每次可以选择$k$枚硬币翻转($0$变为$1$、$1$变为$0$)，初始有$s$枚硬币朝上(表示为$1$)，如果要将其变为$t$枚硬币朝上，求出最少次数，或认为其无解

- 首先当$k$为奇数时，每次翻转会改变$s$的奇偶性；当$k$为偶数时，永远无法改变$s$的奇偶性

  考虑不改变奇偶性的一轮操作，即连续的两次翻转，由于将$s$枚$1$变为$t$枚$1$等价于将$n-s$枚$0$变为$n-t$枚$0$，所以不妨假设$s\le\lfloor\frac n2\rfloor$，在此基础上：

  - 若$k>\lfloor\frac n2\rfloor$，因为一次翻转等价于“选取$n-k$枚硬币翻转后将全部硬币翻转”，所以两次翻转会涉及两次“翻转全部硬币”，抵消后等价于两次均选取$n-k$枚硬币翻转

  - 所以只需要考虑$k\le\lfloor\frac n2\rfloor$的情况

    考虑第一次选择$a_1=0$枚$1$、$b_1=k$枚$0$、第二次选择$a_2=k$枚$1$、$b_2=0$枚$0$

    则两次翻转后，$s$不变，在此基础上，单独使$a_1$增大可得$s-2a_1$，其中$0\le a_1\le\min(k,s)$

    单独使$b_2$增大可得$s+2b_2$，其中$0\le b_2\le\min(k,n-s-k)$

    因此两次翻转后，$s$可变为$[\max(s-2k,0),\min(s+2k,n)]$中任意和$s$奇偶性相同的数

    经过$2c$次反转后，$s$可变为$[\max(s-2ck,0),\min(s+2ck,n)]$中任意和$s$奇偶性相同的数

  - 某些情况下，奇数次操作也有可能是最优解，这时只需要考虑第一次操作能将$s$变成的范围$[l,r]$，再套用上述逻辑可得$[\max(l-2ck,0),\min(r+2ck,n)]$中任意和$s$奇偶性相同的数

    其中$l=|k-s|、r=n-|k-(n-s)|$

- 因此取$K=\min(k,n-k)、S=\min(s,n-s)、T=[S=s]t+[S\ne s](n-t)$

  若$S$与$T$奇偶性相同，若$K$为奇数则答案为$\lceil\frac{|S-T|}{K}\rceil$，若$K$为偶数则同时考虑奇数次操作的情况，取偶数次操作、奇数次操作中的最小值即可

  若$S$与$T$奇偶性不同，若$K$为奇数则答案为奇数次操作，即$1+\max(\lceil\frac{l-T}{K}\rceil,\lceil\frac{T-r}{K}\rceil,0)$，若$K$为偶数则无解

- ```
  // using i64 = long long;
  // void solve() {
  //     i64 n, k, s, t;
  //     cin >> n >> k >> s >> t;
  //     k = min(k, n - k);
  //     if (k == 0) {
  //         cout << (min(s, n - s) == min(t, n - t) ? 0 : -1) << '\n';
  //         return;
  //     }
  //     if (s > (n >> 1)) {
  //         s = n - s;
  //         t = n - t;
  //     }
  //     i64 l, r;
  //     if ((s & 1) ^ (t & 1)) {
  //         if (k & 1) {
  //             l = abs(k - s), r = n - abs(k - n + s);
  //             l += (l & 1) ^ (t & 1);
  //             r -= (r & 1) ^ (t & 1);
  //             cout << 1 + max(max((l - t) / k + ((l - t) % k != 0), (t - r) / k + ((t - r) % k != 0)), 0LL) << '\n';
  //         } else {
  //             cout << -1 << '\n';
  //         }
  //     } else {
  //         if (k & 1) {
  //             cout << abs(s - t) / k << '\n';
  //         } else {
  //             l = abs(k - s), r = n - abs(k - n + s);
  //             l += (l & 1) ^ (s & 1);
  //             r -= (r & 1) ^ (s & 1);
  //             cout << min(abs(s - t) / k, 1 + max(max((l - t) / k + ((l - t) % k != 0), (t - r) / k + ((t - r) % k != 0)), 0LL)) << '\n';
  //         }
  //     }
  // }

### `J. Fastest Coverage Problem`

- 给定$n\cross m$的$01$矩阵，其中$1$每过$1$单位时间会将上下左右的$0$翻转为$1$，除此之外，还可以在初始时将一个$0$翻转为$1$

  求出将所有元素变为$1$所花的最少时间

- 考虑二分答案，对答案$t$，可以对每一个$mat[x][y]=0$进行判断，如果翻转它能够使整个矩阵在$t$内全部翻转为$1$，则满足$t\ge\max(|x-x'|+|y-y'|)$，其中$(x',y')$为在不进行任何初始翻转时，在$t$内无法被翻转的点，取$\max$表示求出离$(x,y)$最远的$(x',y')$

  将绝对值符号拆开，将有四种情况，以$t\ge\max(x-x'+y-y')$为例，由于$x、y$是被遍历的数，因此可以视$x、y$为常数，则式子变为：$t-x-y\ge\max(-x'-y')$

  因此在遍历前将$\max(-x'-y')$求出即可，只需要提前进行一遍多源$bfs$，就能求出某个$0$在不进行任何初始翻转时第一次被翻转的时间，因此预处理后每次`check`只需要一次遍历就能将$\max(-x'-y')$求出

  其余三种情况为：$t-x+y\ge\max(-x'+y')、t+x-y\ge\max(x'-y')、t+x+y\ge\max(x'+y')$

  只需要找到一个$0$，同时满足上面四种情况即可

- ```c++
  const int INF = 0x3f3f3f3f, dir[4][2] {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};
  void solve() {
      int n, m;
      cin >> n >> m;
      vector<vector<int>> mat(n, vector<int>(m)), dis(n, vector<int>(m, INF));
      queue<pair<int, int>> q;
      for (int i = 0; i < n; ++i) {
          for (int j = 0; j < m; ++j) {
              cin >> mat[i][j];
              if (mat[i][j]) {
                  dis[i][j] = 0;
                  q.emplace(i, j);
              }
          }
      }
      // 多源bfs预处理每一个点的第一次翻转时间
      while (!q.empty()) {
          auto tmp = q.front();
          q.pop();
          for (int i = 0; i < 4; ++i) {
              int x = tmp.first + dir[i][0], y = tmp.second + dir[i][1];
              if (x >= 0 && x < n && y >= 0 && y < m && dis[x][y] > dis[tmp.first][tmp.second] + 1) {
                  dis[x][y] = dis[tmp.first][tmp.second] + 1;
                  q.emplace(x, y);
              }
          }
      }
      int l = 0, r = n + m, mid;
      while (l <= r) {
          mid = l + r >> 1;
          int mhddis[4] = {-INF, -INF, -INF, -INF};
          for (int i = 0; i < n; ++i) {
              for (int j = 0; j < m; ++j) {
                  if (dis[i][j] > mid) {
                      mhddis[0] = max(mhddis[0], -i - j);
                      mhddis[1] = max(mhddis[1], -i + j);
                      mhddis[2] = max(mhddis[2], i - j);
                      mhddis[3] = max(mhddis[3], i + j);
                  }
              }
          }
          bool check = 0;
          for (int i = 0; i < n && !check; ++i) {
              for (int j = 0; j < m && !check; ++j) {
                  if (mid - i - j >= mhddis[0] && 
                      mid - i + j >= mhddis[1] && 
                      mid + i - j >= mhddis[2] && 
                      mid + i + j >= mhddis[3]) {
                          check = 1;
                  }
              }
          }
          if (check) {
              r = mid - 1;
          } else {
              l = mid + 1;
          }
      }
      cout << l;
  }
  ```

  