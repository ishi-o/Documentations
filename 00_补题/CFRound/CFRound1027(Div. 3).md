### `A. Square Year`

读入一个数，检查是否是完全平方数，如果是，输出零、它的开方即可

### `B. Not Quite a Palindromic String`

对一个长度$n$（$n$是偶数）的$01$字符串，定义好对是$a_i=a_{n-i+1}$，$1\le i\le n$

可以重排整个字符串，并给定一个$k$，询问是否有重排方案，使得好对数刚好是$k$对

无论有多少对$0$的好对和$1$的好对，对$0$和$1$的贡献都是偶数，且有多少对$0$和多少对$1$可以任意分配

所以优先考虑剩下的$\begin{align}\frac{n}2-k\end{align}$个不好对，易得$0$和$1$的个数必须不小于$\begin{align}\frac{n}2-k\end{align}$，并且减去它以后剩下的$0$和$1$的个数分别都是偶数，才是一个合法的字符串

### `C. Need More Arrays`

首先考虑不进行删除，会分割成多少个区间：容易得到，类似这样的序列$1122236789$会被分成$[112223]$和$[6789]$两个区间，即考虑将所有**相等的元素合并**为一个元素，那么一个区间就是一个**自然增长的序列**

然后考虑删除哪些元素：对于一个自然增长的序列，肯定希望将两端元素保留，然后隔一个元素删一个元素，就能得到最多的区间，即$\begin{align}\left\lfloor\frac{len+1}2\right\rfloor\end{align}$，然后对每个自然增长的序列都计算一遍即可

### `D. Come a Little Closer`

只能动一个点，且只能选择一次矩阵包围所有的点，那么遍历所有的点，每次遍历无视这个点，并计算包围剩余点的最小的矩阵面积，即$\begin{align}S_i=(\max_{j\ne i}(x_j)-\min_{j\ne i}(x_j)+1)(\max_{j\ne i}(y_j)-\min_{j\ne i}(y_j)+1)\end{align}$

易得$S$一定不小于剩余的点数，如果$S>n-1$，那么这个被无视的点可以直接放进去，不需要增大$S$

反之如果$S==n-1$，那么必须扩充一行或一列，加上纵长和横长中的较小者即可

遍历时记录最小的面积即可，这种需要随时取出、插入一个离散点，点的某一坐标可能重复，且需要随时计算剩余点坐标的最小、最大值的要求可以用两个多值集合$\rm multiset$实现

注意取出一个点时，需要$s.erase(s.find(x))$而不是$s.erase(x)$，后者会将所有相等元素全部删去

### `E. Kirei Attacks the Estate`

给定一棵以$1$为根的树，给定一个点权序列$[a_1,\cdots,a_n]$，定义交替和为$\begin{align}\sum_{i=1}^n(-1)^{i-1}a_i\end{align}$；每个节点的一个交替和为它到它的任意一个父节点或它本身的路径中，途径节点产生的点权序列的交替和；每个节点的$danger$为最大的交替和；求所有节点的$danger$

这是一个从上到下的树形$dp$，只要知道父节点的$\min$和$\max$，就能知道当前节点的$\max$和$\min$，具体的转移方程为：
$$
\min_{son}=\min(val_{son},val_{son}-\max_{parent})\\
\max_{son}=\max(val_{son},val_{son}-\min_{parent})
$$

### `F. Small Operations`



### `G. Build an Array`