### `C. Stack`

- 给定一个序列$P$，定义$f(P)$为从左到右使$P$的元素加入一个从栈底到栈顶递增的单调栈中，最后返回值为栈中剩余的元素个数，求所有序列产生的$(f(P))^3$的和

- 这道排列组合问题应用贡献法分析，贡献法就是将大贡献不断细分，找到贡献为常数$c$的最小单位，再按不同角度合并这些最小单位，得到一个更简单的角度，对排列/组合数进行计数

- 如这道题，很难快速求出$f(P)=k$的排列数，且数据范围提示我们单测需要较快的速度完成

  因此需要对贡献进行划分，题目将一个排列的贡献视为$k^3$(设$f(P)=k$)，注意到由于$k>0$，故$k^3=\left(\begin{matrix}k\\1\end{matrix}\right)+6\left(\begin{matrix}k\\2\end{matrix}\right)+6\left(\begin{matrix}k\\3\end{matrix}\right)$

  题外话$\begin{align}n^k=\sum_{i=0}^k\left\{\begin{matrix}n\\i\end{matrix}\right\}n^{\underline i}=\sum_{i=0}^k\left\{\begin{matrix}n\\i\end{matrix}\right\}i!\left(\begin{matrix}n\\i\end{matrix}\right)\end{align}$，其中$若n\ne0,则\left\{\begin{matrix}n\\0\end{matrix}\right\}=0$

  因此可以将一个排列的贡献分为这三大类，“从栈中选取$1/2/3$个元素”的贡献

  具体每一类，又可分为$\begin{align}\sum_{i}从栈中选出i、\sum_{i\ne j}从栈中选出i,j、\sum_{i\ne j\ne k}从栈中选出i,j,k\end{align}$这些小类

  权值分别对应$1、6、6$

  然后就是重新将所有排列的贡献按上述这样分类、合并，即计排列数

- 考虑初始序列为空(初始只有$1$个空隙、每填充一个元素后空隙数增加$1$)，要从最后的单调栈中能取到元素$i$，那么所有$x<i$必须在$i$之前填充，共有$(i-1)!$种填充方法；$i$本身只能填充在最后一个空隙，有$1$种填充方法；大于$i$的元素可随意放置在任意空隙中，即$\begin{align}\prod_{k=i+1}^nk\end{align}$

  故第一类的排列数为$\begin{align}C_1=\sum_{i=1}^n\frac{n!}{i}\end{align}$

  同理，要从最后的单调栈中能取到元素$i、j$，那么$x<i$个元素共有$(i-1)!$种方法、$i<x<j$的元素共有$\begin{align}\prod_{k=i+1}^{j-1}k\end{align}$种方法、$x>j$的元素共有$\begin{align}\prod_{k=j+1}^nk\end{align}$，因此第二类的排列数为$\begin{align}C_2=\sum_{i=1}^{n-1}\sum_{j=i+1}^n\frac{n!}{ij}\end{align}$

  同理第三类的排列数为$\begin{align}\sum_{i=1}^{n-2}\sum_{j=i+1}^{n-1}\sum_{k=j+1}^nC_3=\frac{n!}{ijk}\end{align}$

  只需要对$n!$以及后续三项预处理即可，答案为$\begin{align}C_1+6C_2+6C_3\end{align}$

- 预处理：通过递推公式可得

  $\begin{align}&C_2[n]=\sum_{i=1}^{n-1}(\sum_{j=i+1}^{n-1}\frac{1}{ij}+\frac1{in})=C_2[n-1]+\sum_{i=1}^{n-1}\frac1{in}=C_2[n-1]+\frac{C_1[n-1]}n\\&C_3[n]=\sum_{i=1}^{n-2}\sum_{j=i+1}^{n-1}(\sum_{k=j+1}^{n-1}\frac1{ijk}+\frac1{ijn})=C_3[n-1]+\sum_{i=1}^{n-2}\sum_{j=i+1}^{n-1}\frac1{ijn}=C_3[n-1]+\frac{C_2[n-1]}n\end{align}$

  由于数据过大，需要取模

### `D. Beautiful Matrix`

- 给定$n、m$，构造$n\cross n$矩阵$A$，满足：

  - 所有$0\le A_{i,j}\le m$
  - 所有$A_{i,1}=0$
  - 所有$A_{i,j}\le A_{i,j+1}$
  - 所有$i<k、j<l$，有$A_{i,j}+A_{k,l}\le A_{i,l}+A_{k,j}$

  求所有合法的$A$的个数

- 考虑对第四个条件变形，有$A_{i,j}-A_{i,l}\le A_{k,j}-A_{k,l}$，由$i<k$以及$\le$的传递性，可转化为$A_{i,j}-A_{i,l}\le A_{i+1,j}-A_{i+1,l}$，取$l=j+1$，得$A_{i,j}-A_{i,j+1}\le A_{i+1,j}-A_{i+1,j+1}$

  记$B_{i,j}=A_{i,j+1}-A_{i,j}$，则问题转化为求出$B$的个数，其中$B$为$n$行$n-1$列矩阵，第一行总和为$A_{1,n}\le m$，每一列从上至下单调不增

  考虑再对每一列进行像上述那样的差分操作，记$C_{i,j}=B_{i,j}-B_{i+1,j}$则问题转化为求出$C$的个数，其中$C$为$n$行$n-1$列矩阵，第一行总和仍为$A_{1,n}\le m$，最后一行为$B_{n,j}$，每一列的总和为$B_{1,j}$

  那么每一列的方案数就是将$B_{1,j}=x$分为$n$个数(可为$0$)，通过隔板法可知$C_{x+n-1}^{n-1}$

  那么$x$的生成函数就是$\begin{align}f(t)=\sum_{x\ge0}C_{x+n-1}^{x}t^x=\frac1{(1-t)^n}\end{align}$，因为由广义二项式定理$\begin{align}C_{x+n-1}^{x}=\frac{(x+n-1)^{\underline {x}}}{x!}=\frac{(x+n-1)\cdots(n)}{x!}=\frac{(-1)^x(-n)^{\underline x}}{x!}=(-1)^xC_{-n}^x\end{align}$

  那么$n-1$列的$n-1$个变量$x_i$的联合分布为$\begin{align}\frac1{(1-t)^{n(n-1)}}\end{align}$，再反过来由广义二项式定理展开得$\begin{align}(-1)^x\sum_{x\ge 0}C_{-n(n-1)}^xt^x\end{align}$

  由限制$\begin{align}\sum_ix_i\le m\end{align}$，故求该联合分布的前$m+1$项系数和即可，即$\begin{align}\sum_{x=0}^mC_{n^2-n+x-1}^x=\sum_{x=0}^mC_{n^2-n+x-1}^{n^2-n-1}=C_{n^2-n+m}^{n^2-n}\end{align}$，由上指标求和得出，或由部分和的生成函数得出

### `K. Maximum GCD`

- 给定一个序列$A$，初始可以且尽可以进行一次操作：选取区间$[l,r]$使它们均加上非负整数$k$

  求整个序列所有数的$\gcd$的最大值，若为正无穷则输出$0$

- 首先，若整个序列所有元素相等，则最大值为正无穷

  由于$\gcd(a,b)=\gcd(a,b-a)$，因此$\gcd(A)=\gcd(B)$，其中$B$为$A$的差分序列，那么区间加等价于使$B_l+k$、使$B_{r+1}-k$

  由于可以修改$1/2$个$B$中的元素，所以可以对序列$B$中所有数的所有因子计数$cnt[1:1e5]$(单个元素$B_i$的一种因子只记一次)，从大到小遍历所有因子$d$，若“$cnt[d]=n$或$cnt[d]=n-1$”或“$cnt[d]=n-2$且$d|a_n$”则取$d$为答案

  但有个特例：$0$是任何数的倍数，需要单独计数，具体来说若$0$的数量为$n-2$，则答案为$\max(A)$，在判断$cnt[d]$是否满足条件时，还需要加上$0$的数量

  时间复杂度为$O(n\sigma(\max(A)))$，其中$\sigma(x)$为$x$的因子种类数

- ```c++
  vector<vector<int>> fac(100002, vector<int>());
  vector<int> a(100004), b(100004);
  map<int, int, greater<int>> cnt;
  void init() {
      for (int i = 1; i <= 100000; ++i) {
          for (int j = i; j <= 100000; j += i) {
              fac[j].push_back(i);
          }
      }
  }
  void solve() {
      int n, cnt0 = 0, mx = 0;
      cin >> n;
  	fill(a.begin(), a.begin() + n + 2, 0);
      fill(b.begin(), b.begin() + n + 2, 0);
      cnt.clear();
      for (int i = 1; i <= n; ++i) {
          cin >> a[i];
          b[i] = abs(a[i] - a[i - 1]);
          for (auto& c : fac[b[i]]) {
              ++cnt[c];
          }
          cnt0 += b[i] == 0;
          mx = max(mx, a[i]);
      }
      if (cnt0 == n - 1) {
          cout << 0 << '\n';
          return;
      } else if (cnt0 == n - 2) {
          cout << mx << '\n';
          return;
      }
      int ans = 1;
      for (auto& [x, y] : cnt) {
          if (y + cnt0 == n || 
              y + cnt0 == n - 1 || 
              (y + cnt0 == n - 2 && a[n] % x == 0)) {
                  cout << x << '\n';
                  return;
          }
      }
  }
  ```


### `L. Minimum Parenthesis String`

- 给定$n$，需要生成一个$2n$长的合法括号序列，且给定$m$个区间$[l_i,r_i]$，要求每个区间内至少有一个左括号

  规定左括号的字典序更小，求满足上述要求的字典序最小的合法括号序列

- 首先应该用尽可能少的左括号、且在最少的同时保证左括号字典序最小，来满足这$m$个区间，然后将剩余的左括号全部放在尽可能左边的位置，最后检查括号序列是否合法即可

  但这和区间选点问题有所区别，要求放置的左括号字典序最小，那么可以这样考虑：从大到小遍历区间的左端点，并记录当前已放置的最左边的左括号位置$p$，由于从大到小遍历左端点，因此当前遍历的区间的左端点一定$\le p$，只需要判断右端点，若$\ge p$，则不需要新放置，否则将新的左括号放在当前区间的左端点处即可
