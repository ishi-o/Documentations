### `E. Endless Ladders`

- 题意：给定一个由$x^2-y^2,x\ne y\in N^+$组成的有序序列，任意给定一对$(a,b)$，求$|a^2-b^2|$的排名
- 打表找规律，可以发现所有奇数(除$1$)均存在、所有$4k$偶数(除$4$)均存在、所有$4k+2$偶数均不存在
- 给定一个数$x$，有$\begin{align}\max(0,\left\lfloor\frac{x-1}4-1\right\rfloor)\end{align}$个偶数在它前面，有$\begin{align}\left\lfloor\frac x2\right\rfloor-1\end{align}$个奇数在它前面
- 因此答案为$\begin{align}\left\lfloor\frac x2\right\rfloor+\max(0,\left\lfloor\frac{x-1}4-1\right\rfloor)\end{align}$

### `G. Symmetry Intervals`

- 题意：给定一个字符串$S$，$q$次查询，每次查询一个模式串$T$，问有多少区间$[u,v],u\le v$使得$\forall i\in[u,v],S_{i+offset}=T_i$

- 既然这个偏移量是不变的，那么进行一次匹配即可

  重点是一个连续的长度为$L$的成功匹配的区间，有多少个子区间$[u,v]$

  这个问题也很简单，答案是$C_L^2+L$，前者为$u<v$的情况、后者为$u=v$的情况

- ```c++
  void solve() {
      cin >> t >> a;
      long long ans = 0;
      for (i = len = 0; i < t.size(); ++i) {
          if (s[i + a - 1] == t[i]) {
              ++len;
          } else {
              ans += ((len * (len - 1)) >> 1) + len;
              len = 0;
          }
      }
      ans += ((len * (len - 1)) >> 1) + len;
      cout << ans << endl;
  }

### `K. Museum Acceptance`

- 题意：给定一个简单无向图，其中每个结点至少有一个出度、最多有三个出度，出度编号$0,1,2$，游标满足：

  - 初始时，从出发节点的$0$号门离开
  - 若游标从节点的$x$号门进入，则从节点的$(x+1)\%d$号门离开，其中$d$为该节点的出度

  求出游标从每个节点出发时，它可能走过的边的数量(重复走、正向反向走均计一次)

- 根据这样的游走方式，从某个节点$x$号门出发一定能推出从$(x-1+d)\%d$号门进入，即每个门都处于一个环内，只需要统计所有的环、统计环的边数、统计某个节点属于哪个环即可

- ```c++
  #include <bits/stdc++.h>
  using namespace std;
  int n, d[200010], v, cir[200010], circnt = 1;
  struct Info {
      int to, tod, cir;
  }infos[200010][3];
  void dfs(int i, int j, unordered_set<int>& dir, unordered_set<int>& undir) {
      if (infos[i][j].cir != 0) {
          return;
      }
      int to = infos[i][j].to, tod = (infos[i][j].tod + 1) % d[to];
      if (dir.find(j * 1000000 + i) != dir.end()) {
          
      }
      dir.insert(j * 1000000 + i);
      undir.insert(i < to ? j * 1000000 + i : tod * 1000000 + to);
      dfs(to, tod, dir, undir);
  }
  void solve() {
      cin >> n;
      for (int i = 1; i <= n; ++i) {
          cin >> d[i];
          for (int j = 0; j < d[i]; ++j) {
              cin >> infos[i][j].to;
          }
      }
      for (int i = 1; i <= n; ++i) {
          for (int j = 0; j < d[i]; ++j) {
              for (int k = 0; k < d[infos[i][j].to]; ++k) {
                  if (infos[infos[i][j].to][k].to == i) {
                      infos[i][j].tod = k;
                      break;
                  }
              }
          }
      }
      unordered_set<int> dirst, undirst;
      for (int i = 1; i <= n; ++i) {
          for (int j = 0; j < d[i]; ++j) {
              dirst.clear();
              undirst.clear();
              dfs(i, j, dirst, undirst);
          }
      }
  }
  int main() {
      ios::sync_with_stdio(0);
      cin.tie(0), cout.tie(0);
      solve();
  }