[toc]

### `G`_加边

签到题，记录度数是奇数的点（一定是偶数个）然后两两配对即可

```c++
#include <bits/stdc++.h>
using namespace std;
int d[100010], ans[100010];
int main() {
    int n, m, u, v, cnt = 0;
    cin >> n >> m;
    for (int i = 0; i < m; ++i) {
        cin >> u >> v;
        ++d[u];
        ++d[v];
    }
    for (int i = 1; i <= n; ++i) {
        if (d[i] & 1) {
            ans[cnt++] = i;
        }
    }
    cout << (cnt >> 1) << endl;
    for (int i = 0; i < (cnt >> 1); ++i) {
        cout << ans[i << 1] << ' ' << ans[(i << 1) + 1] << endl;
    }
}
```

### `I`_王国求策

因为两排相冲的城市是一一对应的，不存在重复，那么分类讨论就是：

- $s$和$t$在不同排：如果相冲则$No$，否则它们可以直接相连，为$Yes$
- 它们在同一排：看$n$的个数，易得必须使$n>2$才至少有一个中转点，使得它们相连；否则找不到一个方案使它们可达

有一个很史的点是$s==t$的特判，不知道为什么要有这个点还不说清楚...

```c++
#include <bits/stdc++.h>
using namespace std;
int n, s, t, a[200010];
void solve() {
    cin >> n >> s >> t;
    for (int i = 1; i <= n; ++i) {
        cin >> a[i];
    }
    if (s == t) {
        cout << "Yes\n";
    }
    else if ((s <= n && t <= n) || (s > n && t > n)) {
        cout << (n >= 3 ? "Yes\n" : "No\n");
    }
    else {
        if (s > t) {
            swap(s, t);
        }
        cout << (a[s] == t ? "No\n" : "Yes\n");
    }
}
int main() {
    int _;
    cin >> _;
    while (_--) {
        solve();
    }
}
```

### `F`_年少的誓约II

对于每一个时刻，可以将时针、分针转化为角度，并计算出从起始点转到这个时刻所需的代价

注意时针的角度除了时针数乘$30\degree$以外，还要加上分针导致的偏移，即$\begin{align}\frac{分针数}{60}30\degree\end{align}$，为了方便，将角度都乘以二

因为一天最多有$720$个时刻，所以可以暴力算出来最优的时刻

赛时一直在想各种分支判断，最后换成暴力也不知道之前写的哪儿出错了...

```c++
#include <bits/stdc++.h>
using namespace std;
namespace mysolve {
    int x0, y0, x1, y1, x2, y2, xd, yd, ans, ansx, ansy, tmp;
    int deg(int h, int m) {
        int md = m * 12, hd = h * 60 + m;
        return min((xd - hd + 720) % 720, (hd - xd + 720) % 720) + min((yd - md + 720) % 720, (md - yd + 720) % 720);
    }
    void solve() {
        cin >> x0 >> y0 >> x1 >> y1 >> x2 >> y2;
        yd = y0 * 12;
        xd = x0 * 60 + y0;
        ans = INT_MAX;
        ansx = 0;
        ansy = 0;
        for (int start = x1 * 60 + y1; start <= x2 * 60 + y2; ++start) {
            tmp = deg(start / 60, start % 60);
            if (tmp < ans) {
                ans = tmp;
                ansx = start / 60;
                ansy = start % 60;
            }
        }
        cout << ansx << ' ' << ansy << endl;
    }
}
int main() {
    int _;
    cin >> _;
    while (_--) {
        mysolve::solve();
    }
}
```

### `A`_GD终极节奏实验室

题意：找出一个序列内所有满足$\gcd(a_{l\sim r})=\min(a_{l\sim r})$的区间的个数

为了满足区间内$\gcd(a_{l\sim r})=\min(a_{l\sim r})$的性质，对于这样的区间，如果$a_i$是区间$[l,r]$内的最小值，那么对其它$j\ne i\wedge j\in[l,r]$的数有$a_j\equiv 0({\rm mod}\ a_i)$，也就是$a_j$一定是$a_i$的整数倍

如果对每一个$a_i$，找出其向左/向右最远的$l_i$和$r_i$，使$a_{l_i}$或$a_{r_i}$恰好不是$a_i$的整数倍，那么以$a_i$为区间最小值的区间的贡献就是$(r_i-i)\times(i-l_i)$

这样的要求可以通过单调栈来维护，并以$O(n)$的复杂度求出所有的$l_i$和$r_i$，例如求$r_i$就是从左到右遍历序列，如果栈不为空且当前元素不是栈顶元素的整数倍，则退栈且让$r_{栈顶元素}\leftarrow 当前元素$（因为此后的元素不再可能是栈顶元素的$r$了），直到退出循环让当前元素入栈，如果入栈前栈不为空，那么根据要求，栈内的所有元素的$r$都不可能是当前元素，上述操作是完全符合要求的；最后如果栈仍有元素，则它们的$r$全为$n+1$
所有的$l_i$的求解同理

因为存在两个元素相等的情况，为了防止重复统计，需要对$l$或者$r$中的一个做改动，例如添加对$l$的限制：最远的满足$a_{l_i}$不是$a_i$的整数倍或$a_{l_i}\ne a_i$，那么同时包含$a_{l_i}$和$a_i$的区间只会在$l_i$处被统计，在$i$处不会被统计

```c++
#include <bits/stdc++.h>
using namespace std;
int n, a[100010], l[100010], r[100010];
stack<int> stk;
int main() {
    cin >> n;
    for (int i = 1; i <= n; ++i) {
        cin >> a[i];
    }
    for (int i = 1; i <= n; ++i) {
        while (!stk.empty() && a[i] % a[stk.top()] != 0) {
            r[stk.top()] = i;
            stk.pop();
        }
        stk.push(i);
    }
    while (!stk.empty()) {
        r[stk.top()] = n + 1;
        stk.pop();
    }
    for (int i = n; i; --i) {
        while (!stk.empty() && (a[i] % a[stk.top()] != 0 || a[i] == a[stk.top()])) {
            l[stk.top()] = i;
            stk.pop();
        }
        stk.push(i);
    }
    while (!stk.empty()) {
        l[stk.top()] = 0;
        stk.pop();
    }
    long long ans = 0;
    for (int i = 1; i <= n ;++i) {
        ans += (r[i] - i) * (i - l[i]);
    }
    cout << ans;
}
```

### `K`_微信小游戏

假设每一列（一共$m$列）从上到下连续的颜色相同的方块个数是$x_i$，那么$1\le x_i\le n$，至少需要$n-x_i$次操作才能使这一列的颜色全部相同

因为不同列的颜色必须不同，所以对于顶部颜色相同的列，只能选择一列保留它的颜色，其它列只能吃剩下的颜色；贪心地想，选择$x_i$最大的那一列保留，其余颜色相同的列都需要$n$次操作，能使方案数最小

因此统计每一列的$x_i$并且按$x$从大到小排序然后遍历，并维护一个颜色集合来判断当前列是否保留顶部的颜色即可

总时间复杂度为$O(nm)$，因为$n$和$m$比较小，所以可以接受

```c++
#include <bits/stdc++.h>
using namespace std;
unordered_set<int> col;
struct node{
    bool flag;	// 读入是一行一行读的, 所以flag用来标记当前列的当前元素是否仍然连续
    int col, cnt;	// cnt: 即上文的x
    bool operator<(const node& rhs) const {
        return cnt > rhs.cnt;
    }
}c[2010];
int main() {
    int n, m, tmp;
    scanf("%d%d", &n, &m);
    for (int i = 0; i < m; ++i) {
        scanf("%d", &c[i].col);
        ++c[i].cnt;
    }
    for (int i = 1; i < n; ++i) {
        for (int j = 0; j < m; ++j) {
            scanf("%d", &tmp);
            if (!c[j].flag && tmp == c[j].col) {
                ++c[j].cnt;
            }
            else {
                c[j].flag = true;
            }
        }
    }
    sort(c, c + m);
    int ans = 0 ;
    for (int i = 0; i < m; ++i) {
        if (col.find(c[i].col) != col.end()) {
            ans += n;
        }
        else {
            ans += n - c[i].cnt;
            col.insert(c[i].col);
        }
    }
    printf("%d", ans);
}
```

### `H`_王国迁移

检索到“使最大值最小”，而且$\max_{i=1}^nf(i)$具有单调性，考虑二分答案

考虑如何写$check()$，对于给定的最大值$x$，每一个原本的城市的最大容量是$\begin{align}\left\lfloor\frac{x}{c_i}\right\rfloor\end{align}$，设为$y_i$

由于一组居民中的每一个人可以去到除冲突城市以外的任意城市（不同人之间可以去不同的城市），所以要求就是$\begin{align}\forall i\in[1,n],\sum_{i\ne a_i} y_i\ge b_i\end{align}$，因为当一组居民不得不去到冲突城市时，他们和分配到非冲突城市的其它组居民可以随意交换

此外，必须保证$\begin{align}\sum y_i\ge\sum b_i\end{align}$，这是显然的，因为只有这样才有交换的空间

这样的合法性检查是$O(n)$的，总时间复杂度为$O(n\log n)$

```c++
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
int n, a[200010], b[200010], c[200010];
ll d[200010], smb;		// d即上文的y
bool ck(ll x) {
    ll sum = 0;
    for (int i = 1; i <= n; ++i) {
        d[i] = x / c[i];
        sum += d[i];
    }
    if (smb > sum) {
        return false;
    }
    bool ans = true;
    for (int i = 1; i <= n; ++i) {
        if (sum - d[a[i]] < b[i]) {
            ans = false;
            break;
        }
    }
    return ans;
}
void solve() {
    cin >> n;
    smb = 0;
    for (int i = 1; i <= n; ++i) {
        cin >> a[i];
    }
    for (int i = 1; i <= n; ++i) {
        cin >> b[i];
        smb += b[i];
    }
    for (int i = 1; i <= n; ++i) {
        cin >> c[i];
    }
    ll l = 1, r = 1000000000000LL, m;
    while (l <= r) {
        m = l + r >> 1;
        if (ck(m)) {
            r = m - 1;
        }
        else {
            l = m + 1;
        }
    }
    cout << l << endl;
}
int main() {
    int _;
    cin >> _;
    while (_--) {
        solve();
    }
}
```