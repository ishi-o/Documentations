### 子集和问题

- 子集和(`SOS`，`Sum Over Subsets`)是一个`NP`完全问题，其描述为：给定一个集合$S$和整数$t$，判定是否存在$S$的一个子集$T$，使得这个子集的元素和恰好等于$t$
  更一般地，给定一个集合的函数$f(T)$，判定是否存在$S$的一个子集$T$，使得$f(T)$满足某个条件

- 其最优解的复杂度是指数级别的，考虑$S$的每一个子集，即对这$n$个元素的每一个元素都考虑取与不取，即有$2^n$种情况，尽管可以用贪心来使子集和迭代式地逼近$t$，判否仍需要遍历所有子集，一个解法如下：

  考虑将该问题转化为子集和的前缀和，即一个$n$维数组，其中每一维度都只有$\{0,1\}$两种取值，那么就像计算二维前缀和一样，通过扫地似的遍历计算$n$维前缀和，即每次迭代时固定其它维度的前缀和不变，只计算新加入维度的前缀和
  为了让维度可以随时变化而不需要写$n$个$n$重循环，对子集进行状态压缩，则前缀和数组可以变为一个一维数组：
  ```c++
  int p[1 << n];
  for (int i = 0; i < n; ++i) {	// n次计算前缀和, 每次只调整一个维度
      // 遍历所有子集, 使所有子集中, 第i个元素为1的子集的和加上第i个元素为0的子集的和
      // 即, 使p[...1....] += p[...0....], 其中标出的位表示第i个元素取与不取
      // 则p[...1....]就是第i维度上的前缀和
      for (int j = 0; j < (1 << n); ++j) {
          if (j & (1 << i)) {	// 第i位为1
              p[j] += p[j ^ (1 << i)];
          }
      }
  }
  ```

  很清晰地可以看出，时间复杂度为$O(n2^n)$
  可以通过迭代过程稍微优化这个算法，即每次迭代基于包含前$i-1$个元素的所有子集的和，来计算包含前$i$个元素的所有子集的和，并维护一个集合来记录出现过的子集和
  在最坏情况下，第$i$次迭代后，答案集合中的个数为$\begin{align}2^i\end{align}$，即总的遍历次数为$\begin{align}\sum_{i=2}^n2^{i-1}=2^n-2\end{align}$

- 完全多项式时间的近似算法：

