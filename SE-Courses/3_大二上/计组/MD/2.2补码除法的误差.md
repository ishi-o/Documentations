### 取模和取余

所谓误差，必须定义一个正确的值，这种误差可仿照取模和取余的区别来说明：

设被除数$x$、除数$y$、商$q$、余数$r$

取余运算在求商时，商向零取整，此时$r$与$x$符号一致

取模运算在求商时，商向下取整，此时$r$与$y$符号一致

两种运算都**满足$x=qy+r$**，但两种方法得出的$q$和$r$确实不同，其中$q$最多相差一

先说结论：**原码除法**是**求余运算**，**补码除法**是**求模运算**，若以“末位恒置一”法来对末位上商，会有误差

### 原码除法的余数校正

教材中并没有提到原码加减交替法最后余数是否需要校正，事实上“不恢复余数”指的是将中间过程优化

因原理为先化成两**绝对值相除**，所以得到的**余数和商都应该是正的**(若为负需要恢复余数)，且此时商是向零取整的(因为是正除正)，满足$|x|=|qy|+r$

要想在代入符号后仍满足$x=qy+r$，可枚举得到：

$\begin{matrix}x&y&q&r&说明\\正&正&正&不变&x=qy+r\\正&负&负&不变&x=(-q)(-y)+r\\负&正&负&取相反数&-x=(-q)y+r\\负&负&正&取相反数&-x=q(-y)+r\end{matrix}$

总结：**$r$与$x$符号一致**

### 补码除法的误差

教材中并未要求对假商和假余数的校正

首先，教材中的除法是不完整的：教材中的最后一步得到的“余数”，它不满足$x=qy+r$

可能是因为教材中只想快速得到商，而不需要余数

<img src="D:\Picture\Screenshots\屏幕截图 2024-11-24 153457.png" style="zoom:75%;" />

右移后，仍需根据上次上商进行加减法($x=-0.1001、y=+0.1101$)，完整步骤应是：

$\begin{matrix}&1.1001&|&1010&|&异号,上商0\\&1.0010&|&1010\ \ \ &|&\leftarrow1位\\+&0.1101&|&&|&上商0,加y\\&———&+&———&+&————\\&1.1111&|&1010\underline1&|&末位恒置1\end{matrix}$

可验算，最后这个$1.1111$才是满足$x=qy+r$的余数

其次，这个余数和商什么时候会有误差？

- 若定义求余运算中的商为真商，当最后这个余数和被除数符号不同时，才会有误差，具体来说：
  - 商为正数时，商会比真商大一，余数加除数后等于真余数
  - 商为负数时，商会比真商小一，余数减除数后等于真余数
- 若定义求模运算中的商为真商，当最后这个余数和除数符号不同时，会有误差：
  - 根据之前的上商规则，而不是“恒置一”来上商，最后一次上商后不移位并进行加/减运算，能自然完成余数校正
- 可以发现，“末位恒置一”法既不是取模运算也不是取余运算，这个误差不是一致的
- 由于计算机中均用补码表示，故除法或取模时向下取整会有更好的性质，运算更快

### 主流语言的除法

- `C++`、`C#`、`JS`和`Java`的除法是求余运算，商向零取整
- `Python`的除法是求模运算，商向下取整；`math.fmod()`方法返回求余运算得到的余数

